name: Codex Review Gate

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - ready_for_review
      - synchronize
  pull_request_review:
    types:
      - submitted
      - edited
      - dismissed
  issue_comment:
    types:
      - created

concurrency:
  group: codex-gate-${{ github.repository }}-${{ github.event.pull_request.number || github.event.issue.number || github.event.review.pull_request_url || github.run_id }}
  cancel-in-progress: true

permissions:
  pull-requests: read
  issues: read

jobs:
  rerun-codex-gate:
    name: rerun-codex-gate
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request && github.event.comment.user.login == 'chatgpt-codex-connector[bot]'
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Re-run PR-targeted Codex gate
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pullNumber = context.issue.number;

            const runs = await github.paginate(
              github.rest.actions.listWorkflowRunsForWorkflow,
              {
                owner,
                repo,
                workflow_id: "codex-gate.yml",
                event: "pull_request_target",
                per_page: 100
              }
            );

            const targetRun = runs.find(
              (run) =>
                run.status === "completed" &&
                (run.pull_requests ?? []).some((pr) => pr.number === pullNumber)
            );

            if (!targetRun) {
              core.info(
                `No completed pull_request_target run found for PR #${pullNumber}; nothing to rerun.`
              );
              return;
            }

            await github.rest.actions.reRunWorkflow({
              owner,
              repo,
              run_id: targetRun.id
            });

            core.info(
              `Requested rerun of pull_request_target gate run ${targetRun.id} for PR #${pullNumber}.`
            );

  codex-review-fresh:
    name: codex-review-fresh
    if: github.event_name != 'issue_comment'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      issues: read
    steps:
      - name: Evaluate Codex review gate
        uses: actions/github-script@v7
        with:
          script: |
            const codexLogin = "chatgpt-codex-connector[bot]";

            function parsePullRequestUrl(url) {
              if (typeof url !== "string") {
                return null;
              }

              try {
                const parsed = new URL(url);
                const parts = parsed.pathname.split("/").filter(Boolean);
                if (parts.length < 5) {
                  return null;
                }

                if (parts[0] !== "repos" || parts[3] !== "pulls") {
                  return null;
                }

                const number = Number(parts[4]);
                if (!Number.isInteger(number) || number <= 0) {
                  return null;
                }

                return {
                  owner: parts[1],
                  repo: parts[2],
                  number
                };
              } catch {
                return null;
              }
            }

            let pull_number = context.payload.pull_request?.number ?? null;
            let apiOwner = context.repo.owner;
            let apiRepo = context.repo.repo;

            const parsedReviewPull = parsePullRequestUrl(
              context.payload.review?.pull_request_url
            );

            if (parsedReviewPull) {
              apiOwner = parsedReviewPull.owner;
              apiRepo = parsedReviewPull.repo;
              if (!pull_number) {
                pull_number = parsedReviewPull.number;
              }
            }

            if (!pull_number && context.issue?.number) {
              pull_number = context.issue.number;
            }

            if (!pull_number) {
              core.setFailed("Unable to determine pull request number for Codex review gate.");
              return;
            }

            let pr = null;

            try {
              const response = await github.rest.pulls.get({
                owner: apiOwner,
                repo: apiRepo,
                pull_number
              });
              pr = response.data;
            } catch (error) {
              core.setFailed(
                `Failed to fetch pull request #${pull_number}: ${error.message}`
              );
              return;
            }

            if (
              !pr?.number ||
              !pr?.head?.sha ||
              !pr?.base?.repo?.owner?.login ||
              !pr?.base?.repo?.name
            ) {
              core.setFailed("Unable to resolve pull request number and current HEAD SHA.");
              return;
            }

            const owner = pr.base.repo.owner.login;
            const repo = pr.base.repo.name;
            pull_number = pr.number;
            const headSha = pr.head.sha;

            core.info(`Evaluating Codex gate for PR #${pull_number} at HEAD ${headSha}.`);

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const hasCodexReviewForHead = reviews.some(
              (review) =>
                review.user?.login === codexLogin && review.commit_id === headSha
            );

            let hasCodexSummaryCommentForHead = false;

            if (!hasCodexReviewForHead) {
              let headIntroducedAt = pr.created_at ?? null;

              try {
                const timelineEvents = await github.paginate(
                  github.rest.issues.listEventsForTimeline,
                  {
                    owner,
                    repo,
                    issue_number: pull_number,
                    per_page: 100
                  }
                );

                const headEvents = timelineEvents.filter(
                  (event) =>
                    event?.event === "committed" &&
                    event?.commit_id === headSha &&
                    typeof event?.created_at === "string"
                );

                headEvents.sort(
                  (a, b) => new Date(b.created_at) - new Date(a.created_at)
                );

                if (headEvents[0]?.created_at) {
                  headIntroducedAt = headEvents[0].created_at;
                }
              } catch (error) {
                core.info(
                  `Timeline lookup failed; falling back to PR created_at for Codex comment freshness: ${error.message}`
                );
              }

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: pull_number,
                per_page: 100
              });

              hasCodexSummaryCommentForHead = comments.some((comment) => {
                if (comment.user?.login !== codexLogin) {
                  return false;
                }

                if (typeof comment.body !== "string") {
                  return false;
                }

                if (!/^\s*Codex Review:/i.test(comment.body)) {
                  return false;
                }

                if (!headIntroducedAt) {
                  return true;
                }

                return (
                  new Date(comment.created_at).getTime() >=
                  new Date(headIntroducedAt).getTime()
                );
              });
            }

            if (!hasCodexReviewForHead && !hasCodexSummaryCommentForHead) {
              core.setFailed(
                "Codex review missing for current HEAD. Comment '@codex review' to generate one."
              );
              return;
            }

            core.info(
              "Codex review gate passed: current HEAD has Codex approval evidence (review or summary comment)."
            );
