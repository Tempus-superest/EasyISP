name: Codex Review Gate

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - ready_for_review
      - synchronize
  pull_request_review_thread:
    types:
      - resolved
      - unresolved
  pull_request_review:
    types:
      - submitted
      - edited
      - dismissed

concurrency:
  group: codex-gate-${{ github.repository }}-${{ github.event.pull_request.number || github.event.pull_request_review.pull_request.number || github.event.pull_request_review_thread.pull_request.number || github.event.review.pull_request_url || github.run_id }}
  cancel-in-progress: true

permissions:
  pull-requests: read
  issues: read

jobs:
  codex-review-fresh:
    name: codex-review-fresh
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate Codex review gate
        uses: actions/github-script@v7
        with:
          script: |
            const codexLogin = "chatgpt-codex-connector[bot]";

            function parsePullRequestUrl(url) {
              if (typeof url !== "string") {
                return null;
              }

              try {
                const parsed = new URL(url);
                const parts = parsed.pathname.split("/").filter(Boolean);
                if (parts.length < 5) {
                  return null;
                }

                if (parts[0] !== "repos" || parts[3] !== "pulls") {
                  return null;
                }

                const number = Number(parts[4]);
                if (!Number.isInteger(number) || number <= 0) {
                  return null;
                }

                return {
                  owner: parts[1],
                  repo: parts[2],
                  number
                };
              } catch {
                return null;
              }
            }

            let pull_number = context.payload.pull_request?.number ?? null;
            let apiOwner = context.repo.owner;
            let apiRepo = context.repo.repo;

            const parsedReviewPull = parsePullRequestUrl(
              context.payload.review?.pull_request_url
            );

            if (parsedReviewPull) {
              apiOwner = parsedReviewPull.owner;
              apiRepo = parsedReviewPull.repo;
              if (!pull_number) {
                pull_number = parsedReviewPull.number;
              }
            }

            if (!pull_number && context.issue?.number) {
              pull_number = context.issue.number;
            }

            if (!pull_number) {
              core.setFailed("Unable to determine pull request number for Codex review gate.");
              return;
            }

            let pr = null;

            try {
              const response = await github.rest.pulls.get({
                owner: apiOwner,
                repo: apiRepo,
                pull_number
              });
              pr = response.data;
            } catch (error) {
              core.setFailed(
                `Failed to fetch pull request #${pull_number}: ${error.message}`
              );
              return;
            }

            if (
              !pr?.number ||
              !pr?.head?.sha ||
              !pr?.base?.repo?.owner?.login ||
              !pr?.base?.repo?.name
            ) {
              core.setFailed("Unable to resolve pull request number and current HEAD SHA.");
              return;
            }

            const owner = pr.base.repo.owner.login;
            const repo = pr.base.repo.name;
            pull_number = pr.number;
            const headSha = pr.head.sha;

            core.info(`Evaluating Codex gate for PR #${pull_number} at HEAD ${headSha}.`);

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const hasCodexReviewForHead = reviews.some(
              (review) =>
                review.user?.login === codexLogin && review.commit_id === headSha
            );

            if (!hasCodexReviewForHead) {
              core.setFailed(
                "Codex review missing for current HEAD. Comment '@codex review' to generate one."
              );
              return;
            }

            const unresolvedCodexThreads = [];
            let hasNextPage = true;
            let after = null;

            while (hasNextPage) {
              const result = await github.graphql(
                `
                  query CodexThreads(
                    $owner: String!
                    $repo: String!
                    $pullNumber: Int!
                    $after: String
                  ) {
                    repository(owner: $owner, name: $repo) {
                      pullRequest(number: $pullNumber) {
                        reviewThreads(first: 100, after: $after) {
                          nodes {
                            isResolved
                            comments(first: 100) {
                              nodes {
                                author {
                                  login
                                }
                              }
                            }
                          }
                          pageInfo {
                            hasNextPage
                            endCursor
                          }
                        }
                      }
                    }
                  }
                `,
                {
                  owner,
                  repo,
                  pullNumber: pull_number,
                  after
                }
              );

              const threads =
                result?.repository?.pullRequest?.reviewThreads?.nodes ?? [];
              const pageInfo =
                result?.repository?.pullRequest?.reviewThreads?.pageInfo ?? null;

              for (const thread of threads) {
                const comments = thread?.comments?.nodes ?? [];
                const isCodexOwned = comments.some(
                  (comment) => comment?.author?.login === codexLogin
                );

                if (isCodexOwned && thread?.isResolved === false) {
                  unresolvedCodexThreads.push(thread);
                }
              }

              hasNextPage = Boolean(pageInfo?.hasNextPage);
              after = pageInfo?.endCursor ?? null;
            }

            if (unresolvedCodexThreads.length > 0) {
              core.setFailed(
                "Unresolved Codex review threads remain. Resolve all Codex conversations to pass."
              );
              return;
            }

            core.info(
              "Codex review gate passed: current HEAD has a Codex review and no unresolved Codex-owned threads."
            );
